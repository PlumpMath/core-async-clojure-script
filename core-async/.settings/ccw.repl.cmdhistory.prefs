cmdhistory=["(go (Thread/sleep 3)\\n    (println \\"hello\\"))" "(go (Thread/sleep 3000)\\n    (println \\"hello\\"))" "(\u2013 1 2)" "(+ 1 2)" "(\u2013 1 2)" "(+ 1 2)" "(put\! c \\"hello\\")" "(consuming c)" "(producing c 500 1)" "(async/close\! c)" "(consuming c)" "(producing 1000 1)" "(producing c 1000 1)" "(producing c 2000 2)" "(producing c 1333 3)" "(swap\! condition false)" "@condition" "(reset\! condition false)" "@condition" "(async/)" "(reset\! condition true)" "(put\! c \\"hello\\")" "(consuming c)" "(reset\! condition true)" "(reset\! condition false)" "(consume-multi c1 c2)" "(put\! c1 \\"hello\\")" "(consume-multi c1 c2)" "(put\! c2 \\"hello\\")" "(consume-multi c1 c2)" "(put\! c2 \\"hello\\")" "(+ 2 1)" "(for [x [1 2 3]]\\n  (str x))" "(for [x (reverse [1 2 3])]\\n  (str x))" "(apply str [\\"1\\" \\"2\\" \\"3\\"])" "(render [1 2 3])" "(defn render [v]\\n  (apply str\\n    (for [q (reverse p)]\\n      (str \\"<div>\\" q \\"</div>\\"))))" "(defn render [p]\\n  (apply str\\n    (for [q (reverse p)]\\n      (str \\"<div>\\" q \\"</div>\\"))))" "(render 1 2 3)" "(render [1 2 3])" "(defn render [p]\\n  (apply str\\n    (for [q (reverse p)]\\n      (str \\"<div>\\" q \\"</div>\\\\n\\"))))" "(render [1 2 3])" "(println *1)" "(conj 1 [2 3 ])" "(conj [2 3 ] 1)" "(peekn (conj [] 1) 20)" "(defn peekn\\n  \\"Returns vector of (up to) n items from the end of vector v\\"\\n  [v n]\\n  (if (> (count v) n)\\n    (subvec v (- (count v) n))\\n    v))" "(peekn (conj [] 1) 20)" "(+ 1 2)" "(+ 1 2 3 4 5)" "(+ (/ 1 2) (- 8 1))" "(let\\n  [a (/ 1 2)\\n   b (- 8 1)]\\n  (+ a b))" "(fn [x] (+ 1 x))" "((fn [x] (+ 1 x)) 2)" "(def a 2)" "a" "(defn f [x] (+ 1 x))" "f" "(f 2)" "[1 2 3]" "(def v [1 2 3])" "(get v 0)" "(mapv (fn [x] (* 2 x)) v)" "(defn f [v]\\n  (let [x (get v 0)\\n        y (get v 1)]\\n    (+ x y)))" "(f [1 2])" "(defn f [[x y]]\\n  (+ x y))" "(f [1 2])" "{\\"term1\\" 1, \\"term2\\" 2}" "{\\"term1\\" 1 \\"term2\\" 2}" "(def m {\\"term1\\" 1 \\"term2\\" 2})" "m" "(get m \\"term1\\")" "(get m \\"term1\\" 3)" "(get m \\"term3\\" 3)" "\:oeu" "(def m {\:term1 1 \:term2 2})" "(get m \:term1)" "(\:term2 m)" "m" "(defn f [m]\\n  (let [x (\:x m)\\n        y (\:y m)]\\n    (+ x y)))" "(f {\:x 2 \:y 3})" "(defn f [{\:keys [x y] \:as m}]\\n  (println m)\\n  (+ x y))" "(f {\:x 2 \:y 3})" "(defn f [{\:keys [x y]}]\\n  (+ x y))" "(f {\:x 2})" "(defn f [{\:keys [x y] \:or [y 0]}]\\n  (+ x y))" "(f {\:x 2})" "(defn f [{\:keys [x y]}]\\n  (+ x y))" "(f {\:x 2 \:y 3})" "(do\\n  (Tread/sleep 3000)\\n  (println \\"hello stan\\"))" "(do\\n  (Thread/sleep 3000)\\n  (println \\"hello stan\\"))" "(go\\n  (Thread/sleep 3000)\\n  (println \\"hello stan\\"))" "(go\\n  (Thread/sleep 10000)\\n  (println \\"hello stan\\"))" "(+ 1 2)" "(do\\n  (Thread/sleep 3000)\\n  (println \\"hello stan\\"))" "(def c (chan))" "c" "(go (let [value (<\! c)]\\n      (println value)))" "(go (>\! c \\"hello stan\\"))" "(go (let [value (<\! c)]\\n      (println value)))" "(go (>\! c \\"hello stan\\") (println \\"done\\"))" "(go (let [value (<\! c)]\\n      (println value)))" "(go (timeout 1000)\\n    (println \\"oeuoeuoeu\\"))" "(go (<\! (timeout 1000))\\n    (println \\"oeuoeuoeu\\"))" "(go (<\! (timeout 3000))\\n    (println \\"oeuoeuoeu\\"))" "(go (while true\\n      (let [value (<\! c)]\\n         (println value))))" "(go (>\! c 1))" "(go (>\! c 3))" "(go (while true\\n      (<\! (timeout 500))\\n      (>\! c 1)))" "(go (while true\\n      (<\! (timeout 1250))\\n      (>\! c 2)))" "(go (while true\\n      (<\! (timeout 2330))\\n      (>\! c 3)))" "(go (let [value (<\! c)]\\n      (println value)))" "(put\! c 1)" "(async/>\!\! c 1)" "(+ 1 2)" "(go (println (>\! c 1)))" "(async/<\!\! c)" "(put\! c 1)" "(async/close\! c)" "(put\! c 1)" "c" "(def a (atom 2))" "a" "@a" "(defer a)" "(deref a)" "(reset\! a 3)" "a" "@a" "(swap\! a \#(+ 4 %))" "(def a (cycle nil))" "(take 10 a)" "(take a 10)" "(def a (cycle 1))" "(take a 10)" "(take 10 a)" "(def a (cycle [nil]))" "(take 10 a)" "(def c (async/onto-chan (chan) a))" "(def a (cycle [1]))" "(def c (async/onto-chan (chan) a))" "(<\!\! c)" "(async/<\!\! c)" "(def a (cycle [1]))" "(def color (atom \:red))" "(def c (async/onto-chan (chan) a))" "(def coloc-chan (async/map<\\n                  (fn [x] (@color))\\n                  c))" "(go (println (<\! coloc-chan)))" "coloc-chan" "c" "(def a [1 1 1 1 1 1 1 1 1 1 1])" "(def color (atom @red))" "(def color (atom \:red))" "(def color-chan (async/map<\\n                  (fn [x] @color)\\n                  (async/onto-chan (chan) a)))" "(go (println (<\! coloc-chan)))" "(go (println (<\! color-chan)))" "(def c (chan))" "(async/close\!)" "(async/close\! c)" "(async/<\!\! c)" "(async/<\!\! (async/map< (fn [x] @color) c))" "@color" "(take 10 a)" "a" "(def c (async/to-chan a))" "(async/<\!\! c)" "(async/<\!\! (async/map< (fn [x] @color) c))" "(def c (async/onto-chan (chan) a false))" "(async/<\!\! (async/map< (fn [x] @color) c))" "(def c (chan))" "(go-loop [value (<\! c)]\\n         (when (not (nil? value))\\n           (println c)\\n           (recur (<\! c))))" "(async/go-loop [value (<\! c)]\\n         (when (not (nil? value))\\n           (println c)\\n           (recur (<\! c))))" "(put\! c 1)" "(close\! c)" "(async/close\! c)" "(def c (chan))" "(async/go-loop [value (<\! c)]\\n         (when (not (nil? value))\\n           (println value)\\n           (recur (<\! c))))" "(put\! c 1)" "(close\! c 1)" "(async/close\! c)" "(def c (chan))" "(async/go-loop [value (<\! c)]\\n         (when (not (nil? value))\\n           (println value)\\n           (<\! (timeout 500))\\n           (recur (<\! c))))" "(put\! c 1)" "(async/onto-chan c [1 2 3] false)" "(async/onto-chan c (cycle [1]) false)" "(close\! c)" "(def c (chan))" "(async/go-loop [value (<\! c)]\\n         (when (not (nil? value))\\n           (println value)\\n           (<\! (timeout 500))\\n           (recur (<\! c))))" "(def c (chan))" "(def color (atom \:red))" "(def c (chan))" "(async/onto-chan c (cycle [1]))" "(def color-channel (async/map< (fn [x] @color) c))" "(async/go-loop [value (<\! color-chan)]\\n         (when (not (nil? value))\\n           (println value)\\n           (<\! (timeout 1000))\\n           (recur (<\! color-chan))))" "(async/go-loop [value (<\! color-channel)]\\n         (when (not (nil? value))\\n           (println value)\\n           (<\! (timeout 1000))\\n           (recur (<\! color-channel))))" "(reset\! color \:blue)" "(close\! color-channel)" "(close\! c)" "(+1 2)" "(+ 1 2)" "(def color (atom \:red))" "(\#(deref a))" "(\#(deref color))" "(\#(deref color) 1)" "(def colors (iterate (fn [x] @color) 1))" "(take 2 colors)" "(reset\! color \:blue)" "(take 2 colors)" "(take 3 colors)" "(reset\! color \:green)" "(take 10 colors)" "(def colors (rest (iterate (fn [x] @color) 1)))" "(def c (chan))" "(def atom-channel [atom]\\n  (let [c (chan)\\n        atom-seq (rest (iterate (fn [x] @atom) nil))]\\n    (async/onto-chan c atom-seq)\\n    c))" "(defn atom-channel [atom]\\n  (let [c (chan)\\n        atom-seq (rest (iterate (fn [x] @atom) nil))]\\n    (async/onto-chan c atom-seq)\\n    c))" "color" "(def c (atom-channel color))" "(go (while true\\n      (<\! (timeout 1000))\\n      (println (<\! c))))" "(reset\! color \:red)" "(reset\! color \:blue)" "(def color (atom \:red))" "(def c (atom-channel color))" "(async/<\!\! c)" "(reset\! color \:blue)" "(async/<\!\! c)" "(def c (atom-channel color))" "(async/<\!\! c)" "(def c (atom-channel color))" "(async/<\!\! c)" "(reset\! color \:red)" "(async/<\!\! c)" "(reset\! color \:yellow)" "(async/<\!\! c)" "(take 10 (iterate inc 0))" "(iterate-chan)" "(def c (atom-chan color))" "(async/<\!\! c)" "(reset\! color \:purple)" "(async/<\!\! c)" "(conj [123] 1)" "(def c (chan))" "(go (while true\\n      (<\! (timeout 500))\\n      (>\! c 1)))" "(go (while true\\n      (let [value (<\! c)]\\n        (println value))))" "(append-take [1 1 2 3] 4 5)" "(conj [1 2 3] 2)" "(append-take [1 2 3 4] 4 5)" "c" "(go (while true\\n      (<\! (timeout 500))\\n      (>\! c 1)))" "(go (while true\\n      (<\! (timeout 1000))\\n      (>\! c 2)))" "(go (while true\\n      (<\! (timeout 1666))\\n      (>\! c 2)))" "(go (loop [p []]\\n      (let [value (<\! c)\\n            p (append-take p 10 value)]\\n        (println p)\\n        (recur p))))" "(go (while true\\n      (<\! (timeout 1666))\\n      (>\! c 3)))" "(defn next-mouse-down? [mouse-event mouse-down?]\\n  (condp \= mouse-event\\n    \:mousedown true\\n    \:mouseup false\\n    \:mousemove mouse-down?))" "(use 'clojure.test)" "(is (next-mouse-down? \:mousedown false) true)" "(is (next-mouse-down? \:mousedown false) false)" "(next-mouse-down? \:mousedown true)" "(next-mouse-down? \:mousedown false)" "(\\n  next-mouse-down? \:mousemove false)" "(keyword \\"value\\")" "\:mousedown" "\:mouseup" "\:mousemove" "(defn generate-draw-event [i]\\n  (let [x (mod i 10)\\n        type (cond\\n               (\= x 0) \:draw-start\\n               (\= x 9) \:draw-end)]\\n    {\:x (* x 15) \:y (* 15 (int (/ i 10))) \:type type}))" "(generate-draw-event 1)" "(defn generate-draw-event [i]\\n  (let [x (mod i 10)\\n        type (cond\\n               (\= x 0) \:draw-start\\n               (\= x 9) \:draw-end\\n               \:else \:draw)]\\n    {\:x (* x 15) \:y (* 15 (int (/ i 10))) \:type type}))" "(generate-draw-event 1)" "(+ 1 2 3 )" "(+ 1 2 3)" "(+ (* 1 2) (/ 3 4))" "(let [a (* 1 2)\\n      b (/ 3 4)]\\n  (+ a b))" "(let [a (* 1 2)\\n      b (/ 3 4)\\n      a 7]\\n     (+ a b))" "(let [a (* 1 2)\\n      b (/ 3 4)\\n      a (/ 1 4)]\\n     (+ a b))" "(let [a (* 1 2)\\n      a (/ 1 a)\\n      b (/ 3 4)]\\n     (+ a b))" "a" "b" "core-async.crash/a" "(clojure.core.async/>\!)" "clojure.pprint/pprint" "+" "(defn f [x]\\n  (+ x 2))" "(f 1)" "(fn [x] (+ x 1))" "((fn [x] (+ x 1)) 3)" "[1 2 3 4 5 6]" "(def v [1 2 3 4 5])" "(get v 0)" "(get v 3)" "{\\"x\\" 3 \\"y\\" 4}" "(get {\\"x\\" 3 \\"y\\" 4} \\"x\\")" "\:keyword" "{\:x 3 \:y 5}" "(get {\:x 3 \:y 5} \:x)" "(\:x {\:x 3 \:y 5})" "(defn fact1 [n]\\n  (if (\= n 1)\\n    1\\n    (* n (fact1 (dec n)))))" "(dec 3)" "(fact1 3)" "(fact1 4)" "(fact1 100000)" "(defn fact2 [n]\\n  (let [f (fn [n r]\\n            (if (\= n 1)\\n              r\\n              (f (dec n) (* n r))))]\\n    (f n 1)))" "(fact2 4)" "(defn fact2 [n]\\n  (letfn\\n    (f [n r]\\n       (if (\= n 1)\\n         r\\n         (f (dec n) (* n r))))\\n    (f n 1)))" "(letfn)" "(defn fact2 [n]\\n  (letfn\\n    [(f [n r]\\n       (if (\= n 1)\\n         r\\n         (f (dec n) (* n r))))]\\n    (f n 1)))" "(fact2 4)" "(fact2 100000)" "(fact3 4)" "(fact3 100000)" "(fact3 1000)" "(fact3 100)" "(fact3 10000N)" "(fact2 10000N)" "(fact2 1000N)" "(fact2 10000N)" "(fact2 100000N)" "(fact1 100000N)" "(do (java.lang.Thread/sleep 3000)\\n  (println \\"Hello Stan\\"))" "(+ 1 2)" "(do (java.lang.Thread/sleep 3000)\\n  (println \\"Hello Stan\\"))" "(+ 1 2)" "(go\\n  (java.lang.Thread/sleep 3000)\\n  (println \\"Hello Stan\\"))" "(+ 1 2)" "(go\\n  (java.lang.Thread/sleep 3000)\\n  (println \\"Hello Stan\\")\\n  3)" "(def go-chan (go\\n              (java.lang.Thread/sleep 3000)\\n              (println \\"Hello Stan\\")\\n              3))" "go-chan" "(take\! go-chan)" "(<\!\! go-chan)" "(<\!\! (go\\n      (java.lang.Thread/sleep 3000)\\n      (println \\"Hello Stan\\")\\n      3))" "c" "(go (>\! c 2))" "(go\\n  (let [value (\!< c)]\\n    (println value)))" "(go\\n  (let [value (<\! c)]\\n    (println value)))" "(conj 1 [2 3])" "(conj [2 3] 1)" "(conj [2 3 1] 4)" "(def a [1 2 3])" "(conj a 4)" "a" "(conj-take [1 2 3] 3 4)" "(+ 1 2 3)" "(+ 1N 2N)" "(+ (* 1 2) (/ 2 4))" "(let\\n  [a (* 1 2)\\n   b (/ 2 4)]\\n  (+ a b))" "and" "a" "(let\\n  [a (* 1 2)\\n   b (/ 2 4)]\\n  (+ a b))" "(def a 2)" "a" "(defn f [x]\\n  (* 2 x))" "(f 3)" "f" "(fn [x] (* 3 x))" "((fn [x] (* 3 x)) 4)" "[1 2 3]" "(get [1 2 3] 0)" "(get [1 2 3] 2)" "(def v [1 2 3])" "v" "(conj v 2)" "v" "(conj v 5)" "{\\"x\\" 3, \\"y\\" 5}" "(get {\\"x\\" 3, \\"y\\" 5} \\"x\\")" "\:a" "{\:x 3 \:y 5}" "(get {\:x 3 \:y 5} \:x)" "(\:x {\:x 3 \:y 5})" "(def m {\:x 3 \:y 5})" "m" "(assoc m \:z 6)" "m" "(defn fact [n]\\n  (if (\= n 1)\\n    1\\n    (* n (fact (dec n)))))" "(dec 2)" "(fact 3)" "(fact 1000N)" "(fact 10000N)" "(defn fact2 [n]\\n  (letfn\\n    [(f [n r]\\n       (if (\= n 1)\\n         r\\n         (f (dec n) (* n r))))]\\n    (f n 1)))" "(fact2 10000N)" "(defn fact3 [n]\\n  (loop [n n\\n         r 1]\\n    (if (\= n 1)\\n      r\\n      (recur (dec n) (* n r)))))" "(fact3 10000N)" "(do (println \\"hello\\"))" "(do (Thread/sleep 3000) (println \\"hello\\"))" "(+ 1 2)" "(do (Thread/sleep 3000) (println \\"hello\\"))" "(+ 1 2)" "(go (Thread/sleep 3000) (println \\"hello\\"))" "(+ 1 2)" "(def c (chan))" "c" "(go (println \\"before sending\\") (>\! c 3) (println \\"after sending\\"))" "(go (println (<\! c)))" "(go (println \\"before sending\\") (>\! c 3) (println \\"after sending\\"))" "(go (while true (<\! (timeout 500)) (>\! c 1)))" "(go (while true (println (<\! c))))" "(go (while true\\n      (<\! (timeout 1333))\\n      (>\! c 2)))" "(go (while true\\n      (<\! (timeout 1533))\\n      (>\! c 3)))" "(go (while true (println (str \\"second\: \\" (<\! c)))))" "(conj [1 2 3] 4)" "(take [1 2 3] 2)" "(take 2 [1 2 3])" "(conj-take [1 2 3] 3 4)" "(go (loop [p []]\\n      (println p)\\n      (recur (conj-take p 10 (<\! c)))))" "(def c (chan))" "(go (loop [p []]\\n      (println p)\\n      (recur (conj-take p 10 (<\! c)))))" "(go (while true\\n      (<\! (timeout 1333))\\n      (>\! c 2)))" "(go (while true\\n      (<\! (timeout 1333))\\n      (>\! c 1)))" "(go (while true\\n      (<\! (timeout 1333))\\n      (>\! c 3)))" "(put\! c 4)"]
eclipse.preferences.version=1
